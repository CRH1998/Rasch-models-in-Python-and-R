library(Rfast)
library(rje)
library(eRm)



################################################################################
#                         Simulation functions                                 #
################################################################################


SML_sim <- function(k, n, manual_diffs = NULL, manual_abilities = NULL, misspecified_items = NULL){
  
  
  # Check if manual_diffs and manual_abilities are provided
  if(is.null(manual_diffs)){
    # If manual_diffs are not provided we simulate difficulties from a standard normal distribution
    manual_diffs <- rnorm(k)
  }
  
  if(is.null(manual_abilities)){
    # If manual_abilities are not provided we simulate abilities from a standard normal distribution
    manual_abilities <- rnorm(n)
  }
  
  
  # Probability matrix - calculate probability to answer correctly using the Rasch model
  probability_matrix <- outer(manual_abilities, manual_diffs, FUN = function(x, y) expit(x - y))
  
  # Response matrix - simulate responses based on the probabilities in the probability matrix
  response_matrix <- data.frame(matrix(rbinom(k * n, 1, probability_matrix), nrow = n, ncol = k))
  
  # Rename dataframe columns to item1, item2,...,itemk
  colnames(response_matrix) <- paste0("item", 1:k)
  
  
  if (!is.null(misspecified_items)){
    # If misspecified_items are provided, simulate responses for the items specified in the misspecified_items argument
    for (i in 1:length(misspecified_items)){
      response_matrix[, misspecified_items[[i]]] <- rbinom(n, 1, 0.5)
    }
  }
  
  
  return(data.frame(response_matrix))
  
}



PCM_sim <- function(k, n, PCM_options = 5, manual_diffs = NULL, manual_abilities = NULL, item_reponse_to_add = NULL){
  
  # This function genereates polytomous data based on dichotomous data generated by the SML_sim function.
  # The function adds the responses of items from the dichotomous data, turning it into polytomous data.
  # The user can manually specify which items to add using the item_reponse_to_add argument.
  # If no argument is supplied to item_response_to_add, the function will add the responses based on the
  #     number of levels specified in the PCM_options argument. Default is 5 levels meaning that the function
  #     will add the responses of the first 5 items, the next 5 items, and so on.
  
  
  # Generate dichotomous data
  response_matrix <- SML_sim(k, n, manual_diffs, manual_abilities)
  
  
  
  # Check if item_reponse_to_add is provided
  if (is.null(item_reponse_to_add)){
    
    # Create PCM response matrix by adding the responses of items based on the number of PCM_options
    PCM_response_matrix <- do.call(cbind, by(t(response_matrix), (seq(ncol(response_matrix)) - 1) %/% PCM_options, FUN = colSums))
    
    # Rename columns and rownames
    colnames(PCM_response_matrix) <- paste0("item", 1:ncol(PCM_response_matrix))
    rownames(PCM_response_matrix) <- 1:nrow(PCM_response_matrix)
    
  
  } else {
    
    # If manual addition of items is specified, add the responses of the items specified in the item_reponse_to_add argument
    PCM_response_matrix <- matrix(NA, nrow = n, ncol = length(item_reponse_to_add))
    for (i in 1:length(item_reponse_to_add)){
      PCM_response_matrix[, i] <- rowSums(response_matrix[item_reponse_to_add[[i]]])
    }
    
    # Rename columns and rownames
    colnames(PCM_response_matrix) <- paste0("item", 1:length(item_reponse_to_add))
    rownames(PCM_response_matrix) <- 1:nrow(PCM_response_matrix)
  }
  
  return(data.frame(PCM_response_matrix))
  
}


################################################################################



################################################################################
#                         Simulation study functions                           #
################################################################################

run_SML_simulation_study <- function(n_simulations, n_persons, k_items, manual_diffs, manual_abilities) {
  # Data frame to store results
  results <- data.frame(matrix(NA, nrow = n_simulations, ncol = 2 * k_items))
  colnames(results) <- c(paste0("beta", 1:k_items), paste0("se_beta", 1:k_items))
  
  
  # Simulation loop
  for (i in 1:n_simulations) {
    # Simulate data
    sim_data <- SML_sim(k = k_items, n = n_persons, manual_diffs = manual_diffs, manual_abilities = manual_abilities)
    
    # Fit Rasch model
    RaschFitSimData <- RM(sim_data, sum0 = TRUE)
    
    # Store results
    results[i, 1:k_items] <- RaschFitSimData$betapar
    results[i, (k_items+1):(2*k_items)] <- RaschFitSimData$se.beta
  }

  coverage <- colMeans(t(t(-results[, 1:k_items] - 1.96 * results[, (k_items+1):(2*k_items)]) < manual_diffs & manual_diffs < t(-results[, 1:k_items] + 1.96 * results[, (k_items+1):(2*k_items)])))
  
  beta_mean <- colMeans(results[, 1:k_items])
  beta_sd <- sqrt(colVars(results[, 1:k_items]))
  beta_mean_sd <- colMeans(results[, (k_items+1):(2*k_items)])
  
  
  return(list("Mean of betas" = beta_mean, 
              "Standard deviation of betas" = beta_sd, 
              "Mean of standard deviations" = beta_mean_sd,
              "Coverage" = coverage))
}




run_SML_simulation_studies <- function(n_persons_list = c(50, 100, 200, 400, 800), n_simulations = 100, k_items = 10, manual_diffs = NULL, manual_abilities = NULL){
  
  
  SML_simulation_studies <- list()
  
  for (i in 1:length(n_persons_list)) {
    n <- n_persons_list[i]
    print(paste("Number of persons: ", n))
    manual_abilities <- rnorm(n, 0, 1)
    
    SML_simulation_study <- run_SML_simulation_study(n_simulations = n_simulations, 
                                                     n_persons = n, 
                                                     k_items = k, 
                                                     manual_diffs = manual_diffs, 
                                                     manual_abilities = manual_abilities)
    
    SML_simulation_studies[[i]] <- SML_simulation_study
  }
  
  # Collect betas in a data frame
  SML_simulation_studies_betas <- data.frame(cbind(
    n_persons_list, 
    do.call(rbind, lapply(SML_simulation_studies[1:10], function(x) x$`Mean of betas`))
  ))
  
  # Calculate bias
  SML_simulation_studies_bias <- data.frame(t(t(SML_simulation_studies_betas[,2:11]) + manual_diffs))
  SML_simulation_studies_bias$persons <- n_persons_list
  
  # Collect mean of standard deviations
  SML_simulation_studies_sds <- data.frame(cbind(
    n_persons_list, 
    do.call(rbind, lapply(SML_simulation_studies[1:10], function(x) x$`Mean of standard deviations`))
  ))
  
  # Collect standard deviation of betas
  SML_simulation_studies_betasds <- data.frame(cbind(
    n_persons_list, 
    do.call(rbind, lapply(SML_simulation_studies[1:10], function(x) x$`Standard deviation of betas`))
  ))
  
  # Collect coverage
  SML_simulation_studies_Coverage <- data.frame(cbind(
    n_persons_list, 
    do.call(rbind, lapply(SML_simulation_studies[1:10], function(x) x$Coverage))
  ))
  
  return(list("Betas" = SML_simulation_studies_betas, 
              "Bias" = SML_simulation_studies_bias, 
              "Standard deviations" = SML_simulation_studies_sds, 
              "Standard deviation of betas" = SML_simulation_studies_betasds, 
              "Coverage" = SML_simulation_studies_Coverage))
}







run_PCM_simulation_study <- function(n_simulations, n_persons, k_items, PCM_options, manual_diffs, manual_abilities, item_reponse_to_add) {
  # Data frame to store results
  results <- data.frame(matrix(NA, nrow = n_simulations, ncol = 2 * k_items))
  colnames(results) <- c(paste0("beta", 1:k_items), paste0("se_beta", 1:k_items))
  
  # Simulation loop
  for (i in 1:n_simulations) {
    # Simulate data
    sim_data <- PCM_sim(k = k_items, n = n_persons, PCM_options = PCM_options, manual_diffs = manual_diffs, manual_abilities = manual_abilities, item_reponse_to_add = item_reponse_to_add)
    
    # Fit PCM model
    PCMFitSimData <- PCM(sim_data, sum0 = TRUE)
    
    # Store results
    results[i, 1:k_items] <- PCMFitSimData$betapar
    results[i, (k_items+1):(2*k_items)] <- PCMFitSimData$se.beta
  }

  coverage <- colMeans(t(t(-results[, 1:k_items] - 1.96 * results[, (k_items+1):(2*k_items)]) < manual_diffs & manual_diffs < t(-results[, 1:k_items] + 1.96 * results[, (k_items+1):(2*k_items)])))
  
  beta_mean <- colMeans(results[, 1:k_items])
  beta_sd <- sqrt(colVars(results[, 1:k_items]))
  beta_mean_sd <- colMeans(results[, (k_items+1):(2*k_items)])
  
  
  return(list("Mean of betas" = beta_mean, 
              "Standard deviation of betas" = beta_sd, 
              "Mean of standard deviations" = beta_mean_sd,
              "Coverage" = coverage))
}


################################################################################



################################################################################
#                   Infit/outfit simulation study functions                    #
################################################################################

run_one_InfitOutfit <- function(n_persons, k_items, manual_diffs, manual_abilities = NULL, misspecified_items = NULL, remove_min_max_scores = FALSE) {
  # Simulate data
  sim_data <- SML_sim(k = k_items, n = n_persons, manual_diffs = manual_diffs, manual_abilities = manual_abilities, misspecified_items = misspecified_items)
  

  if (remove_min_max_scores){
    # Remove the minimum and maximum scores from the data
    sim_data <- sim_data[!(rowSums(sim_data) %in% c(0,k_items)),]
  }
  
  # Fit Rasch model
  RaschFitSimData <- RM(sim_data, sum0 = TRUE)
  
  # Get infit/outfit values
  ppRaschFitSim <- person.parameter(RaschFitSimData)
  ifRaschFitSim <- itemfit(ppRaschFitSim)
  
  maxinfit <- max(ifRaschFitSim$i.infitMSQ)
  mininfit <- min(ifRaschFitSim$i.infitMSQ)
  
  maxoutfit <- max(ifRaschFitSim$i.outfitMSQ)
  minoutfit <- min(ifRaschFitSim$i.outfitMSQ)
  
  
  # Store results
  results <- c(maxinfit, mininfit, maxoutfit, minoutfit)
  
  return(results)
}




run_InfitOutfit_simulation_study <- function(n_simulations, n_persons, k_items, manual_diffs, manual_abilities = NULL, misspecified_items = NULL, remove_min_max_scores = FALSE){
  
  # Data frame to store results
  results <- data.frame(matrix(NA, nrow = n_simulations, ncol = 4))
  colnames(results) <- c("maxinfit", "mininfit", "maxoutfit", "minoutfit")
  
  # Simulation loop
  for (i in 1:n_simulations) {
    results[i, ] <- run_one_InfitOutfit(n_persons = n_persons, 
                                        k_items = k_items, 
                                        manual_diffs = manual_diffs, 
                                        manual_abilities = manual_abilities, 
                                        misspecified_items = misspecified_items, 
                                        remove_min_max_scores = remove_min_max_scores)
  }
  
  return(results)
}


